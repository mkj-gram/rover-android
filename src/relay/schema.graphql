input AddCampaignInput {
  name: String!
  campaignClass: String!
  clientMutationId: String
}

type AddCampaignPayload {
  campaignEdge: CampaignEdge
  viewer: CampaignUser
  roverId: String
  clientMutationId: String
}

enum BackgroundContentMode {
  ORIGINAL
  STRETCH
  TILE
  FILL
  FIT
}

enum BackgroundScale {
  X1
  X2
  X3
}

# A barcode block that contains only the publicly accessible fields
type BarcodeBlock implements Block, HasBackground, HasBarcode, HasBorder {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  barcodeScale: Int!
  barcodeText: String!
  barcodeFormat: BarcodeFormat!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
}

enum BarcodeFormat {
  QR_CODE
  AZTEC_CODE
  PDF417
  CODE_128
}

# Beacon information
type Beacon {
  triggerEnter: Boolean
  anyBeacon: Boolean
  beaconTags: [String]
  beaconNames: [String]
  anyPlace: Boolean
  placeTags: [String]
  placeNames: [String]
}

# Beacon information
input BeaconInput {
  triggerEnter: Boolean
  anyBeacon: Boolean
  beaconTags: [String]
  beaconNames: [String]
  anyPlace: Boolean
  placeTags: [String]
  placeNames: [String]
}

interface Block {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
}

union BlockAction = GoToScreenAction | OpenUrlAction

type BooleanPredicate implements Predicate {
  attribute: String!
  booleanValue: Boolean!
  booleanComparison: String!
}

# A button block that contains only the publicly accessible fields
type ButtonBlock implements Block, HasButtonStates {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  disabled: ButtonState!
  highlighted: ButtonState!
  normal: ButtonState!
  selected: ButtonState!
}

type ButtonState implements HasBackground, HasBorder, HasText {
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
  text: String!
  textAlignment: TextAlignment!
  textColor: Color!
  textFont: Font!
}

# Rover Campaign
type Campaign implements Node {
  # The ID of an object
  id: ID!
  name: String
  roverId: String
  state: String
  campaignClass: CampaignClassEnumType
  delivery: [DeliveryEnumType]
  geofenceData: Geofence
  beaconData: Beacon
  scheduleData: Schedule
  audienceData: String
  frequencyLimit: [FrequencyLimit]
  recipients: Int!
  campaignOpens: CampaignOpens!
  experience: Experience
}

enum CampaignClassEnumType {
  location
  scheduled
  automatic
  url
}

# A connection to a list of items.
type CampaignConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [CampaignEdge]
}

# An edge in a connection.
type CampaignEdge {
  # The item at the end of the edge
  node: Campaign

  # A cursor for use in pagination
  cursor: String!
}

# Number of times a campaign was opened by delivery method
type CampaignOpens {
  inbox: Int!
  inapp: Int!
  push: Int!
  uniqueOpens: Int!
}

type CampaignRoot {
  viewer: CampaignUser

  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node
}

type CampaignUser implements Node {
  # The ID of an object
  id: ID!
  name: String
  email: String
  campaigns(state: String = null, roverId: String = null, campaignClass: String = null, after: String, first: Int, before: String, last: Int): CampaignConnection
}

input ChangeCampaignAudienceDataInput {
  id: ID!
  audienceData: String
  clientMutationId: String
}

type ChangeCampaignAudienceDataPayload {
  campaign: Campaign
  viewer: CampaignUser
  clientMutationId: String
}

input ChangeCampaignBeaconDataInput {
  id: ID!
  beaconData: BeaconInput!
  clientMutationId: String
}

type ChangeCampaignBeaconDataPayload {
  campaign: Campaign
  viewer: CampaignUser
  clientMutationId: String
}

input ChangeCampaignFrequencyLimitInput {
  id: ID!
  frequencyLimit: FrequencyLimitInput!
  clientMutationId: String
}

type ChangeCampaignFrequencyLimitPayload {
  campaign: Campaign
  viewer: CampaignUser
  clientMutationId: String
}

input ChangeCampaignGeofenceDataInput {
  id: ID!
  geofenceData: GeofenceInput!
  clientMutationId: String
}

type ChangeCampaignGeofenceDataPayload {
  campaign: Campaign
  viewer: CampaignUser
  clientMutationId: String
}

input ChangeCampaignNameInput {
  id: ID!
  name: String!
  clientMutationId: String
}

type ChangeCampaignNamePayload {
  campaign: Campaign
  viewer: CampaignUser
  clientMutationId: String
}

input ChangeCampaignScheduleDataInput {
  id: ID!
  scheduleData: ScheduleInput!
  clientMutationId: String
}

type ChangeCampaignScheduleDataPayload {
  campaign: Campaign
  viewer: CampaignUser
  clientMutationId: String
}

input ChangeCampaignStateInput {
  id: ID!
  state: String!
  clientMutationId: String
}

type ChangeCampaignStatePayload {
  campaign: Campaign
  viewer: CampaignUser
  clientMutationId: String
}

type Color {
  red: Int!
  green: Int!
  blue: Int!
  alpha: Float!
}

# Query ANY or ALL condition
enum condition {
  ANY
  ALL
}

scalar Date

type DatePredicate implements Predicate {
  attribute: String!
  dateValue: DateValue!
  dateComparison: String!
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
# `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
# 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

type DateValue {
  start: DateTime!
  end: DateTime!
}

enum DeliveryEnumType {
  Push
  InApp
  Inbox
}

# Segment of total devices
type DynamicSegment {
  segmentId: ID!
  name: String!
  data: SegmentData!
  predicates: PredicateAggregate!
}

# A barcode block that includes fields related to authoring/editing
type EditableBarcodeBlock implements Block, EditableBlock, HasBackground, HasBarcode, HasBorder {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  clickCount: Int!
  lockStatus: LockStatus!
  name: String!
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  barcodeScale: Int!
  barcodeText: String!
  barcodeFormat: BarcodeFormat!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
}

interface EditableBlock {
  clickCount: Int!
  lockStatus: LockStatus!
  name: String!
}

# A button block that includes fields related to authoring/editing
type EditableButtonBlock implements Block, EditableBlock, HasButtonStates {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  clickCount: Int!
  lockStatus: LockStatus!
  name: String!
  disabled: ButtonState!
  highlighted: ButtonState!
  normal: ButtonState!
  selected: ButtonState!
}

# An experience that includes fields related to authoring/editing
type EditableExperience {
  id: ID!
  homeScreenId: String!
  screens: [EditableScreen!]!
  hasUnpublishedChanges: Boolean!
  isArchived: Boolean!
  isPublished: Boolean!
  name: String!
  simulatorUrl: String!
  viewToken: String!
  versionId: String
  recentAverageDuration: Int
}

# An image block that includes fields related to authoring/editing
type EditableImageBlock implements Block, EditableBlock, HasBackground, HasBorder, HasImage {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  clickCount: Int!
  lockStatus: LockStatus!
  name: String!
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
  image: Image
}

# A rectangle block that includes fields related to authoring/editing
type EditableRectangleBlock implements Block, EditableBlock, HasBackground, HasBorder {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  clickCount: Int!
  lockStatus: LockStatus!
  name: String!
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
}

# A row that includes fields related to authoring/editing
type EditableRow {
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  autoHeight: Boolean!
  blocks: [EditableBlock!]!
  experienceId: ID!
  height: Length!
  id: ID!
  screenId: ID!
  isCollapsed: Boolean!
  name: String!
}

# A screen that includes fields related to authoring/editing
type EditableScreen {
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  autoColorStatusBar: Boolean!
  experienceId: ID!
  id: ID!
  isStretchyHeaderEnabled: Boolean!
  rows: [EditableRow!]!
  statusBarStyle: StatusBarStyle!
  statusBarColor: Color!
  titleBarBackgroundColor: Color
  titleBarButtons: TitleBarButtons
  titleBarButtonColor: Color!
  titleBarText: String!
  titleBarTextColor: Color!
  useDefaultTitleBarStyle: Boolean!
  hasUnpublishedChanges: Boolean!
  name: String!
  views: Int!
}

# A text block that includes fields related to authoring/editing
type EditableTextBlock implements Block, EditableBlock, HasBackground, HasBorder, HasText {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  clickCount: Int!
  lockStatus: LockStatus!
  name: String!
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
  text: String!
  textAlignment: TextAlignment!
  textColor: Color!
  textFont: Font!
}

# A web view block that includes fields related to authoring/editing
type EditableWebViewBlock implements Block, EditableBlock, HasBackground, HasBorder, HasWebView {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  clickCount: Int!
  lockStatus: LockStatus!
  name: String!
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
  isScrollingEnabled: Boolean!
  url: String
}

input EventInput {
  name: String!
  timestamp: String!
  attributes: JSON
}

# An experience that contains only the publicly accessible fields
type Experience {
  id: ID!
  homeScreenId: String!
  screens: [Screen!]!
}

type Font {
  size: Int!
  weight: FontWeight!
}

enum FontWeight {
  ULTRA_LIGHT
  THIN
  LIGHT
  REGULAR
  MEDIUM
  SEMI_BOLD
  BOLD
  HEAVY
  BLACK
}

# Frequency Limits of Campaign
type FrequencyLimit {
  limitCount: Int!
  periodCount: Int!
  periodType: String!
}

# Frequency Limits of Campaign
input FrequencyLimitInput {
  limitCount: Int!
  periodCount: Int!
  periodType: String!
}

enum Gender {
  MALE
  FEMALE
}

# Geofence location information
type Geofence {
  triggerEnter: Boolean
  anyPlace: Boolean
  placeTags: [String]
  placeNames: [String]
}

# Geofence location information
input GeofenceInput {
  triggerEnter: Boolean
  anyPlace: Boolean
  placeTags: [String]
  placeNames: [String]
}

type GeofencePredicate implements Predicate {
  attribute: String!
  geofenceValue: GeofenceValue!
  geofenceComparison: String!
}

# Latitude/Longitude coordinates paired with a radius
type GeofenceValue {
  latitude: Float!
  longitude: Float!
  radius: Int!
}

# A button action that navigates to a new screen
type GoToScreenAction {
  experienceId: ID!
  screenId: ID!
}

interface HasBackground {
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
}

interface HasBarcode {
  barcodeScale: Int!
  barcodeText: String!
  barcodeFormat: BarcodeFormat!
}

interface HasBorder {
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
}

interface HasButtonStates {
  disabled: ButtonState!
  highlighted: ButtonState!
  normal: ButtonState!
  selected: ButtonState!
}

interface HasImage {
  image: Image
}

interface HasText {
  text: String!
  textAlignment: TextAlignment!
  textColor: Color!
  textFont: Font!
}

interface HasWebView {
  isScrollingEnabled: Boolean!
  url: String
}

enum HorizontalAlignment {
  LEFT
  RIGHT
  CENTER
  FILL
}

type Image {
  height: Int!
  isURLOptimizationEnabled: Boolean!
  name: String!
  size: Int!
  width: Int!
  url: String!
}

# An image block that contains only the publicly accessible fields
type ImageBlock implements Block, HasBackground, HasBorder, HasImage {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
  image: Image
}

type Insets {
  bottom: Int!
  left: Int!
  right: Int!
  top: Int!
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

type Length {
  unit: Unit!
  value: Float!
}

enum LockStatus {
  UNLOCKED
  PARTIAL
  LOCKED
}

type Mutation {
  trackEvents(events: [EventInput]): String
  addCampaign(input: AddCampaignInput!): AddCampaignPayload
  changeCampaignName(input: ChangeCampaignNameInput!): ChangeCampaignNamePayload
  changeCampaignState(input: ChangeCampaignStateInput!): ChangeCampaignStatePayload
  changeGeofenceData(input: ChangeCampaignGeofenceDataInput!): ChangeCampaignGeofenceDataPayload
  changeBeaconData(input: ChangeCampaignBeaconDataInput!): ChangeCampaignBeaconDataPayload
  changeCampaignScheduleData(input: ChangeCampaignScheduleDataInput!): ChangeCampaignScheduleDataPayload
  changeCampaignAudienceData(input: ChangeCampaignAudienceDataInput!): ChangeCampaignAudienceDataPayload
  changeCampaignFrequencyLimit(input: ChangeCampaignFrequencyLimitInput!): ChangeCampaignFrequencyLimitPayload
}

# An object with an ID
interface Node {
  # The id of the object.
  id: ID!
}

type NumberPredicate implements Predicate {
  attribute: String!
  numberValue: [Int!]!
  numberComparison: String!
}

type Offsets {
  bottom: Length!
  center: Length!
  left: Length!
  middle: Length!
  right: Length!
  top: Length!
}

# A button action that opens a URL in a web browser
type OpenUrlAction {
  url: String!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

enum Position {
  STACKED
  FLOATING
}

# Search predicate for building Segments
interface Predicate {
  attribute: String!
}

# Object containing list of device predicates and list of profile predicates
type PredicateAggregate {
  device: [Predicate]!
  profile: [Predicate]!
  condition: condition!
}

type Profile {
  profileID: String
  firstName: String
  lastName: String
  email: String
  gender: Gender
  age: Int
  phoneNumber: String
  tags: [String]
  traits: JSON
}

type Query {
  campaign: CampaignRoot

  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node
  experience(id: ID!): Experience
  editableExperience(id: ID!): EditableExperience
  dynamicSegment(segmentId: ID, paginationKey: String): [DynamicSegment]
  segmentFromPredicates(predicates: String!, paginationKey: String!): SegmentData
  segmentSchema: SegmentSchema
  sync: SyncResult
}

# A rectangle block that contains only the publicly accessible fields
type RectangleBlock implements Block, HasBackground, HasBorder {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
}

# A row that contains only the publicly accessible fields
type Row implements HasBackground {
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  autoHeight: Boolean!
  blocks: [Block!]!
  experienceId: ID!
  height: Length!
  id: ID!
  screenId: ID!
}

# Schedule of campaign
type Schedule {
  startTime: String
  endTime: String
  days: [String]
  startDate: Date
  endDate: Date
}

# Schedule of campaign
input ScheduleInput {
  startTime: String
  endTime: String
  days: [String]
  startDate: Date
  endDate: Date
}

# Name and Type of attribute available in SegmentSchema
type SchemaAttribute {
  attribute: String!
  type: String!
}

# A screen that contains only the publicly accessible fields
type Screen implements HasBackground {
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  autoColorStatusBar: Boolean!
  experienceId: ID!
  id: ID!
  isStretchyHeaderEnabled: Boolean!
  rows: [Row!]!
  statusBarStyle: StatusBarStyle!
  statusBarColor: Color!
  titleBarBackgroundColor: Color
  titleBarButtons: TitleBarButtons
  titleBarButtonColor: Color!
  titleBarText: String!
  titleBarTextColor: Color!
  useDefaultTitleBarStyle: Boolean!
}

# Payload from a segment page
type SegmentData {
  devices: [JSON!]!
  profiles: [JSON!]!
  segmentSize: Int!
  totalSize: Int!
  nextPageKey: String!
}

# Schema of available predicate attributes
type SegmentSchema {
  deviceSchema: [SchemaAttribute]!
  profileSchema: [SchemaAttribute]!
}

enum StatusBarStyle {
  DARK
  LIGHT
}

type StringPredicate implements Predicate {
  attribute: String!
  stringValue: String!
  stringComparison: String!
}

type SyncResult {
  profile: Profile
}

enum TextAlignment {
  LEFT
  RIGHT
  CENTER
}

# A text block that contains only the publicly accessible fields
type TextBlock implements Block, HasBackground, HasBorder, HasText {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
  text: String!
  textAlignment: TextAlignment!
  textColor: Color!
  textFont: Font!
}

enum TitleBarButtons {
  CLOSE
  BACK
  BOTH
}

enum Unit {
  POINTS
  PERCENTAGE
}

type VersionPredicate implements Predicate {
  attribute: String!
  versionValue: [Int!]!
  versionComparison: String!
}

enum VerticalAlignment {
  TOP
  BOTTOM
  MIDDLE
  FILL
}

# A web view block that contains only the publicly accessible fields
type WebViewBlock implements Block, HasBackground, HasBorder, HasWebView {
  action: BlockAction
  autoHeight: Boolean!
  experienceId: ID!
  height: Length!
  id: ID!
  insets: Insets!
  horizontalAlignment: HorizontalAlignment!
  offsets: Offsets!
  opacity: Float!
  position: Position!
  rowId: ID!
  screenId: ID!
  verticalAlignment: VerticalAlignment!
  width: Length
  backgroundColor: Color!
  backgroundContentMode: BackgroundContentMode!
  backgroundImage: Image
  backgroundScale: BackgroundScale!
  borderColor: Color!
  borderRadius: Int!
  borderWidth: Int!
  isScrollingEnabled: Boolean!
  url: String
}

