syntax = "proto3";

package rover.auth.v1;

option go_package = "auth/v1;auth";

import "google/protobuf/timestamp.proto";

/*
    Token
 */

message Token {
    string key = 1;

    // Maybe add scope access here?
}

/*
    Resource
    name: String representing the name of the resource
          exp -> [ Events, Messages, Experiences ]
 */
message Resource {
    string name = 1;
}

/*
    Account
 */
message Account {
    int32 id = 1;

    // The name of the account example AirMiles
    string name = 2;
    string serverToken = 3;
    string sdkToken = 4;
    string browserToken = 5;

    google.protobuf.Timestamp updated_at = 7;
    google.protobuf.Timestamp created_at = 8;
}

/*
    User
 */
message User {
    int32 id = 1;

    // The name of the user example Jacob
    string name = 2;
    string email = 3;
    string password = 4;

    google.protobuf.Timestamp updated_at = 7;
    google.protobuf.Timestamp created_at = 8;
}

message UserSession {
    int32 id = 1;

    int32 user_id = 2;
    int32 account_id = 3;
    Token jwt_token = 4;

    google.protobuf.Timestamp last_seen = 6;
    google.protobuf.Timestamp expires_at = 7;
    google.protobuf.Timestamp updated_at = 8;
    google.protobuf.Timestamp created_at = 9;

}


/*
    Account Rpc Requests & Replies
 */
message GetAccountRequest {
    // The account id
    int32 account_id = 1;
}

message GetAccountReply {
    Account account = 1;
}


message CreateAccountRequest {
    // The name of the account
    // All other attributes are auto generated
    string name = 1;
}

message CreateAccountReply {
    Account account = 1;
}

message UpdateAccountRequest {
    int32 account_id = 1;

    string name = 2;
}

message UpdateAccountReply {
    Account account = 1;
}


/*
    User Rpc Requests & Replies
 */

message GetUserRequest {
    int32 user_id = 1;
}

message GetUserReply {
    User user = 1;
}

message CreateUserRequest {
    string name = 1;
    string email = 2;
    string password = 3;
}

message CreateUserReply {
    User user = 1;
}

message UpdateUserRequest {
    int32 user_id = 1;
    
    string name = 2;
    string email = 3;
    string password = 4;
}

message UpdateUserReply {
    User user = 1;
}



/*
    Session Rpc Requests & Replies
 */

message CreateUserSessionRequest {
    string email = 1;
    string password = 2;
}

message CreateUserSessionReply {
    UserSession session = 1;
}



message AuthenticateRequest {
    Token token = 1;
}

message AuthenticateReply {

    Account account = 1;

    /* Optional */
    User user = 2;
}

message HasAccessRequest {
    Token token = 1;
    Resource resource = 2;
}

message HasAccessReply {
    bool has_access = 1;
}

/*
    
    Service for handling authenticate of Users and Accounts
    as well as provides ACL to protect resources

 */
service Auth {

    /*
        Basic crud operations for Accounts
     */
    rpc GetAccount(GetAccountRequest) returns (GetAccountReply) {};
    rpc CreateAccount(CreateAccountRequest) returns (CreateAccountReply) {};
    rpc UpdateAccount(UpdateAccountRequest) returns (UpdateAccountReply) {};
    


    /*
        Basic crud operations for Users
     */
    rpc GetUser(GetUserRequest) returns (GetUserReply) {};
    rpc CreateUser(CreateUserRequest) returns (CreateUserReply) {};
    rpc UpdateUser(UpdateUserRequest) returns (UpdateUserReply) {};

    /*
        A user session is simple sign on using email & password based authentication to generate a new JWT token
        A session is not stored in any db instead the token is used to map back to a user
     */
    rpc CreateUserSession(CreateUserSessionRequest) returns (CreateUserSessionReply) {};


    /*
        Checks whether the supplied token either a Rover token or JWT token that maps back to a User or Account
     */
    rpc Authenticate(AuthenticateRequest) returns(AuthenticateReply) {} 
   

    /*
        Checks whether the supplied token either a Rover token or JWT token that maps back to a User or Account
        has access to the requested resource
     */
    rpc HasAccess(HasAccessRequest) returns (HasAccessReply) {};
}
